;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interfaces
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO begin_nt_buffer_write nt_pos_hi, nt_pos_lo
  LDA nt_pos_hi
  STA nt_buf_in_hi
  LDA nt_pos_lo
  STA nt_buf_in_lo
  JSR _begin_nt_buffer_write
ENDM

MACRO write_to_nt_buffer data
  LDA data
  STA nt_buf_in_dt
  JSR _write_to_nt_buffer
ENDM

MACRO end_nt_buffer_write
  JSR _end_nt_buffer_write
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UTILS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO load_pal pal_address
  ;load color pal
  LDA $2002 ; reset the hight/low latch to high
  LDA #$3F
  STA $2006 ; write high byte
  LDA #$00
  STA $2006 ; PPU is now looking at $3F10; the color palette data
    
  LDX #$00
  -:
    LDA pal_address, x
    STA $2007
    INX
    CPX #$20
    BNE -
ENDM

MACRO load_nametable nt_number, nt_pointer
  ;load nametable
  LDA $2002             ; read PPU status to reset the high/low latch
  LDA #$20+(nt_number*$04)
  STA $2006             ; write the high byte of address
  LDA #$00
  STA $2006             ; write the low byte of address
  
  LDA #<nt_pointer
  STA generic_pointer+0
  LDA #>nt_pointer
  STA generic_pointer+1
  
  LDY #$00 ; counter for the loop
  LDX #$04 ; 4*256 = 1k, how much data we copy
  -:
    LDA (generic_pointer), y
    STA $2007             ; write to PPU
    INY
    BNE -
    INC generic_pointer+1
    DEX
    BNE -
ENDM

MACRO check_ondown button_id
  LDA button_ondown
  AND button_id
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GENERATOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO choose_random_room
  -:
    JSR rng
    LDX rng_seed
    LDA dungeon_map, X
  BEQ - ; if room is empty, try again
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CHARACTER CREATION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MACRO fill_ind_stats dest, source
  LDX #$00
  
  ;hp
  LDY source, X
  LDA cc_stat_options, Y
  STA dest, X
  INX
  
  ;mana
  LDY source, X
  LDA cc_stat_options+4, Y
  STA dest, X
  INX
  
  ;str
  LDY source, X
  LDA cc_stat_options+8, Y
  STA dest, X
  INX
  
  ;agl
  LDY source, X
  LDA cc_stat_options+12, Y
  STA dest, X
  INX
  
  ;def
  LDY source, X
  LDA cc_stat_options+16, Y
  STA dest, X
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GAMEPLAY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

OFFER_SPRITE_OAM_LOCATION .equ #(48*4)
STAT_HEART_X .equ #32
STAT_HEART_MAX_X .equ #(32+48)
STAT_MAGIC_X .equ #(32+(48*2))
STAT_MAGIC_MAX_X .equ #(32+(48*3))
STAT_STR_X .equ #32
STAT_AGL_X .equ #(32+48)
STAT_DEF_X .equ #(32+(48*2))
STAT_COIN_X .equ #(32+(48*3))
STAT_GEM_X .equ #(32+(48*4))
STAT_TOP_ROW_Y .equ #200
STAT_BOTTOM_ROW_Y .equ #216
MACRO make_offer
  LDA #0
  STA current_offer_amounts
  STA current_offer_type
    
  check_onChest
  BEQ +
    LDA #%11000000
    STA current_offer_type
    
    LDA offerings+0
    AND #%00001111
    STA current_offer_amounts
    
    JMP +offer_made
  +:
  
  check_onFountain
  BEQ +
    LDA offerings+0 ; get the offer type from the room data
    AND #%00110000
    LSR
    LSR
    LSR ; move it to where it needs to be in current offer data
    ORA #%01001001; add in other metadata (existance, fountain offers, takes gems)
    STA current_offer_type
    
    LDA offerings+2
    STA current_offer_amounts
  
    JMP +offer_made
  +:
  
  
  check_onGhost
  BEQ +
    LDA offerings+0 ; get the offer type from the room data
    AND #%11000000
    LSR
    LSR
    LSR
    LSR
    LSR ; move it to where it needs to be in current offer data
    ORA #%01000000; add in other metadata (just flag existance)
    STA current_offer_type
    
    LDA offerings+1
    STA current_offer_amounts
  
    JMP +offer_made
  +:
  
  +offer_made:
  
  LDA current_offer_type
  AND #%01000000 ; make sure the offer exists
  BNE +
    JMP +no_offer
  +:
    LDA current_offer_type
    AND #%10000000 ; is it a free treasure?
    BEQ +asdfasdf
      LDA STAT_COIN_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      LDA #$FF
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+12
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+16
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+20
      
      JMP +write_values
    +asdfasdf:
    
    ; put positive in correct place
    LDA current_offer_type
    AND #%00001110
    LSR
    CMP #0
    BNE +next_type
      LDA STAT_GEM_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #1
    BNE +next_type
      LDA STAT_HEART_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_TOP_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #2
    BNE +next_type
      LDA STAT_MAGIC_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_TOP_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #3
    BNE +next_type
      LDA STAT_AGL_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #4
    BNE +next_type
      LDA STAT_DEF_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #5
    BNE +next_type
      LDA STAT_STR_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #6
    BNE +next_type
      LDA STAT_MAGIC_MAX_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_TOP_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    CMP #7
    BNE +next_type
      LDA STAT_HEART_MAX_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+4
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+8
      
      LDA STAT_TOP_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
      
      JMP +place_cost
    +next_type:
    
    
    +place_cost:
    ; put negative in correct place
    LDA current_offer_type
    AND #%00000001
    BNE +next_type
      LDA STAT_COIN_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+12
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+16
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+20
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+12
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+16
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+20
      
      JMP +write_values
    +next_type:
    
      LDA STAT_GEM_X
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+12
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+16
      CLC
      ADC #8
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_X+20
      
      LDA STAT_BOTTOM_ROW_Y
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+12
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+16
      STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+20
      
    +write_values:
    ; write values
    LDA current_offer_amounts
    AND #$0F
    CLC
    ADC #1
    STA arguments+0
    JSR byte_to_dec
    LDA returns+1
    STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_I+4
    LDA returns+2
    STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_I+8
    
    LDA current_offer_amounts
    AND #$F0
    LSR
    LSR
    LSR
    LSR
    CLC
    ADC #1
    STA arguments+0
    JSR byte_to_dec
    LDA returns+1
    STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_I+16
    LDA returns+2
    STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_I+20
    
    
    JMP +offer_displayed
  +no_offer:
  
  ; no offer. hide it
  
  LDA #$ff
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+4
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+8
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+12
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+16
  STA $0200+OFFER_SPRITE_OAM_LOCATION+SPRITE_DATA_Y+20
  
  +offer_displayed:
ENDM

CHEST_LOCATION_X .equ #48
CHEST_LOCATION_Y .equ #140
ROOM_DATA_CHEST_BIT .equ #%00000010
MACRO check_onChest
  LDX player_room
  LDA dungeon_map, X
  AND ROOM_DATA_CHEST_BIT
  BEQ +not_on_chest

  LDA actors+ACT_X
  CMP CHEST_LOCATION_X
  BCS +not_on_chest
  
  LDA actors+ACT_Y
  CMP CHEST_LOCATION_Y
  BCC +not_on_chest
  
  LDA #1
  JMP +on_chest
  
  +not_on_chest:
  LDA #0
  +on_chest:
ENDM

FOUNTAIN_RIGHT_LOCATION_X .equ #140
FOUNTAIN_TOP_LOCATION_Y .equ #80
FOUNTAIN_LEFT_LOCATION_X .equ #116
FOUNTAIN_BOTTOM_LOCATION_Y .equ #108
ROOM_DATA_FOUNTAIN_BIT .equ #%00001000
MACRO check_onFountain
  LDX player_room
  LDA dungeon_map, X
  AND ROOM_DATA_FOUNTAIN_BIT
  BEQ +not_on_fountain

  LDA actors+ACT_X
  CMP FOUNTAIN_RIGHT_LOCATION_X
  BCS +not_on_fountain
  
  LDA actors+ACT_Y
  CMP FOUNTAIN_TOP_LOCATION_Y
  BCC +not_on_fountain

  LDA actors+ACT_X
  CMP FOUNTAIN_LEFT_LOCATION_X
  BCC +not_on_fountain
  
  LDA actors+ACT_Y
  CMP FOUNTAIN_BOTTOM_LOCATION_Y
  BCS +not_on_fountain
  
  LDA #1
  JMP +on_fountain
  
  +not_on_fountain:
  LDA #0
  +on_fountain:
ENDM

GHOST_LOCATION_Y .equ #48
GHOST_LOCATION_X .equ #208
ROOM_DATA_GHOST_BIT .equ #%00000100
MACRO check_onGhost
  LDX player_room
  LDA dungeon_map, X
  AND ROOM_DATA_GHOST_BIT
  BEQ +not_on_ghost

  LDA actors+ACT_X
  CMP GHOST_LOCATION_X
  BCC +not_on_ghost
  
  LDA actors+ACT_Y
  CMP GHOST_LOCATION_Y
  BCS +not_on_ghost
  
  LDA #1
  JMP +on_ghost
  
  +not_on_ghost:
  LDA #0
  +on_ghost:

ENDM

MACRO move_actor
  LDA actor_control
  AND #$0F ; ignore everything but d-pad
  BNE +yes_movement
    JMP +no_movement
  +yes_movement:
    AND RIGHT_BUTTON
    BEQ ++
      LDA #2
      STA actors+ACT_FACE,X
      
      move_actor_right_if_possible
    ++:
    
    LDA actor_control
    AND LEFT_BUTTON
    BEQ ++
      LDA #3
      STA actors+ACT_FACE,X
      
      move_actor_left_if_possible
    ++:
    
    LDA actor_control
    AND UP_BUTTON
    BEQ ++
      LDA #1
      STA actors+ACT_FACE,X
      
      move_actor_up_if_possible
    ++:
    
    LDA actor_control
    AND DOWN_BUTTON
    BEQ ++
      LDA #0
      STA actors+ACT_FACE,X
      
      move_actor_down_if_possible
    ++:
  
      
    CLC
    INC actors+ACT_ANIM_TIMER,X

  +no_movement:
ENDM

MACRO buy_stuff
  LDA actor_control
  AND SELECT_BUTTON
  BNE +
    JMP +no_purchase
  +:
  
  LDA current_offer_type
  AND #%01000000
  BNE +
    JMP +no_purchase
  +:
    LDA current_offer_type
    AND #%10000000 ; is it a chest?
    BEQ +not_a_chest
      LDA current_offer_amounts
      CLC
      ADC #1
      CLC
      ADC player_money
      BCC +value_not_full
        LDA #255
      +value_not_full:
      
      STA player_money
      
      LDX player_room
      LDA ROOM_DATA_CHEST_BIT ; remove chest from room
      EOR #$FF
      AND dungeon_map,X
      STA dungeon_map,X
      
      JSR draw_chest
      
      JMP +done_buying
    +not_a_chest:
    
    ; make sure player has enough money
    LDA current_offer_type
    AND #%00000001
    BNE +costs_gems
      ; costs coins
      LDA current_offer_amounts
      AND #$F0 ; just the cost
      LSR
      LSR
      LSR
      LSR
      ; leave off the +1 for now so we can use BCC
      ;CLC
      ;ADC #1 ; get actual cost
      
      CMP player_money
      BCC + ; can't afford
        JMP +done_buying
      +:
      
      ; take away money
      CLC 
      ADC #1
      STA generic_bytes+88 ; save cost because we need to load current money
      LDA player_money
      SEC
      SBC generic_bytes+88
      STA player_money
      
      JMP +can_afford
      
    +costs_gems:
      LDA current_offer_amounts
      AND #$F0 ; just the cost
      LSR
      LSR
      LSR
      LSR
      ; leave off the +1 for now so we can use BCC
      ;CLC
      ;ADC #1 ; get actual cost
      
      CMP player_jewels
      BCC + ; can't afford
        JMP +done_buying
      +:
      ; take away money
      CLC 
      ADC #1
      STA generic_bytes+88 ; save cost because we need to load current money
      LDA player_jewels
      SEC
      SBC generic_bytes+88
      STA player_jewels
      
      JMP +can_afford
    
    +can_afford:
      
      ; give the thing
      LDA current_offer_amounts
      AND #$0F
      CLC
      ADC #1
      STA generic_bytes+69
      
      LDA current_offer_type
      AND #$0F
      LSR
      
      CMP #0
      BNE +next_item
        LDA player_jewels
        CLC
        ADC generic_bytes+69
        BCC +not_too_much
          LDA #255
        +not_too_much:
        
        STA player_jewels
        JMP +done_buying
      +next_item:
      
      CMP #1
      BNE +next_item
        LDA actors+ACT_HP
        CLC
        ADC generic_bytes+69
        CMP actors+ACT_HPMAX
        BCC +not_too_much
          LDA actors+ACT_HPMAX
        +not_too_much:
        
        STA actors+ACT_HP
        JMP +done_buying
      +next_item:
      
      CMP #2
      BNE +next_item
        LDA actors+ACT_MANA
        CLC
        ADC generic_bytes+69
        CMP actors+ACT_MANAMAX
        BCC +not_too_much
          LDA actors+ACT_MANAMAX
        +not_too_much:
        
        STA actors+ACT_MANA
        JMP +done_buying
      +next_item:
      
      CMP #3
      BNE +next_item
        LDA actors+ACT_AGL
        CLC
        ADC generic_bytes+69
        BCC +not_too_much
          LDA #255
        +not_too_much:
        
        STA actors+ACT_AGL
        JMP +done_buying
      +next_item:
      
      CMP #4
      BNE +next_item
        LDA actors+ACT_DEF
        CLC
        ADC generic_bytes+69
        BCC +not_too_much
          LDA #255
        +not_too_much:
        
        STA actors+ACT_DEF
        JMP +done_buying
      +next_item:
      
      CMP #5
      BNE +next_item
        LDA actors+ACT_STR
        CLC
        ADC generic_bytes+69
        CMP #127
        BCC +not_too_much
          LDA #127
        +not_too_much:
        
        STA actors+ACT_STR
        JMP +done_buying
      +next_item:
      
      CMP #6
      BNE +next_item
        LDA actors+ACT_MANAMAX
        CLC
        ADC generic_bytes+69
        BCC +not_too_much
          LDA #255
        +not_too_much:
        
        STA actors+ACT_MANAMAX
        JMP +done_buying
      +next_item:
      
      CMP #7
      BNE +next_item
        LDA actors+ACT_HPMAX
        CLC
        ADC generic_bytes+69
        BCC +not_too_much
          LDA #255
        +not_too_much:
        
        STA actors+ACT_HPMAX
        JMP +done_buying
      +next_item:
      
  +done_buying:
  LDA #1
  STA readout_update_req
  +no_purchase:
ENDM

TOP_WALL_HEIGHT .equ #32
LEFT_WALL_WIDTH .equ #37
RIGHT_WALL_WIDTH .equ #220
BOTTOM_WALL_HEIGHT .equ #155
TOP_DOOR_LEFT .equ #117
TOP_DOOR_RIGHT .equ #140
SIDE_DOOR_TOP .equ #80
SIDE_DOOR_BOTTOM .equ #107

MACRO move_actor_up_if_possible
  ; TEST 1. COLLIDE WITH TOP WALL, MOVE THROUGH DOOR
    LDA actors+ACT_Y,X
    CMP TOP_WALL_HEIGHT
    BCS + ; if actor is below wall; try different test
    
    CPX #0
    BNE +do_not_move ; only the player can move through doors
    
    LDA can_move_up_room
    BEQ +do_not_move ; if the door is closed, you can't pass it
    
    LDA actors+ACT_X,X
    CMP TOP_DOOR_LEFT-1
    BCC +do_not_move
    CMP TOP_DOOR_RIGHT+1
    BCS +do_not_move ;have to be in door to go through it
    
    JMP +do_move ; test passed, move up
  
  +:
  ; TEST 2. TOP OF LEFT DOOR
    LDA actors+ACT_X,X
    CMP LEFT_WALL_WIDTH-1
    BCS + ; actor is right of left wall; try different test
  
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_TOP
    BCS +do_move ; below top of door
    
    JMP +do_not_move ; test failed
    
  +:
  ; TEST 3. TOP OF RIGHT DOOR
    LDA actors+ACT_X,X
    CMP RIGHT_WALL_WIDTH+1
    BCC +do_move ; actor is not within any wall areas
    
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_TOP
    BCS +do_move
    
    JMP +do_not_move
    
  +do_move:
    DEC actors+ACT_Y,X
  +do_not_move:
ENDM

MACRO move_actor_down_if_possible
  ; TEST 1. COLLIDE WITH BOTTOM WALL, MOVE THROUGH DOOR
    LDA actors+ACT_Y,X
    CMP BOTTOM_WALL_HEIGHT
    BCC + ; if actor is above wall; try different test
    
    CPX #0
    BNE +do_not_move ; only the player can move through doors
    
    LDA can_move_down_room
    BEQ +do_not_move ; if the door is closed, you can't pass it
    
    LDA actors+ACT_X,X
    CMP TOP_DOOR_LEFT-1 ; top because I suck at naming things
    BCC +do_not_move
    CMP TOP_DOOR_RIGHT+1
    BCS +do_not_move ;have to be in door to go through it
    
    JMP +do_move ; test passed, move up
  
  +:
  ; TEST 2. BOTTOM OF LEFT DOOR
    LDA actors+ACT_X,X
    CMP LEFT_WALL_WIDTH-1
    BCS + ; actor is right of left wall; try different test
  
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_BOTTOM
    BCC +do_move ; above bottom of door
    
    JMP +do_not_move ; test failed
    
  +:
  ; TEST 3. BOTTOM OF RIGHT DOOR
    LDA actors+ACT_X,X
    CMP RIGHT_WALL_WIDTH+1
    BCC +do_move ; actor is not within any wall areas
    
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_BOTTOM
    BCC +do_move
    
    JMP +do_not_move
    
  +do_move:
    INC actors+ACT_Y,X
  +do_not_move:
ENDM

MACRO move_actor_left_if_possible
  ; TEST 1. COLLIDE WITH LEFT WALL, MOVE THROUGH DOOR
    LDA actors+ACT_X,X
    CMP LEFT_WALL_WIDTH
    BCS + ; if actor is right of wall; try different test
    
    CPX #0
    BNE +do_not_move ; only the player can move through doors
    
    LDA can_move_left_room
    BEQ +do_not_move ; if the door is closed, you can't pass it
    
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_TOP-1
    BCC +do_not_move
    CMP SIDE_DOOR_BOTTOM+1
    BCS +do_not_move ;have to be in door to go through it
    
    JMP +do_move ; test passed, move up
  
  +:
  ; TEST 2. LEFT OF TOP DOOR
    LDA actors+ACT_Y,X
    CMP TOP_WALL_HEIGHT-1
    BCS + ; actor is bellow top wall; try different test
  
    LDA actors+ACT_X,X
    CMP TOP_DOOR_LEFT
    BCS +do_move ; right of left of door
    
    JMP +do_not_move ; test failed
    
  +:
  ; TEST 3. LEFT OF BOTTOM DOOR
    LDA actors+ACT_Y,X
    CMP BOTTOM_WALL_HEIGHT+1
    BCC +do_move ; actor is not within any wall areas
    
    LDA actors+ACT_X,X
    CMP TOP_DOOR_LEFT
    BCS +do_move
    
    JMP +do_not_move
    
  +do_move:
    DEC actors+ACT_X,X
  +do_not_move:
ENDM

MACRO move_actor_right_if_possible
  ; TEST 1. COLLIDE WITH RIGHT WALL, MOVE THROUGH DOOR
    LDA actors+ACT_X,X
    CMP RIGHT_WALL_WIDTH
    BCC + ; if actor is left of wall; try different test
    
    CPX #0
    BNE +do_not_move ; only the player can move through doors
    
    LDA can_move_right_room
    BEQ +do_not_move ; if the door is closed, you can't pass it
    
    LDA actors+ACT_Y,X
    CMP SIDE_DOOR_TOP-1
    BCC +do_not_move
    CMP SIDE_DOOR_BOTTOM+1
    BCS +do_not_move ;have to be in door to go through it
    
    JMP +do_move ; test passed, move up
  
  +:
  ; TEST 2. RIGHT OF TOP DOOR
    LDA actors+ACT_Y,X
    CMP TOP_WALL_HEIGHT-1
    BCS + ; actor is bellow top wall; try different test
  
    LDA actors+ACT_X,X
    CMP TOP_DOOR_RIGHT
    BCC +do_move ; left of right of door
    
    JMP +do_not_move ; test failed
    
  +:
  ; TEST 3. RIGHT OF BOTTOM DOOR
    LDA actors+ACT_Y,X
    CMP BOTTOM_WALL_HEIGHT+1
    BCC +do_move ; actor is not within any wall areas
    
    LDA actors+ACT_X,X
    CMP TOP_DOOR_RIGHT
    BCC +do_move
    
    JMP +do_not_move
    
  +do_move:
    INC actors+ACT_X,X
  +do_not_move:
ENDM

MACRO test_pause
  LDA actor_control
  AND START_BUTTON
  BEQ +
    ; pause the game
    LDA #1
    STA paused
    
    ; clear the start button so it doesn't instantly unpause
    LDA START_BUTTON
    EOR #$FF
    AND button_ondown
    STA button_ondown
  +:
ENDM
