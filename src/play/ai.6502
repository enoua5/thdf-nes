MELEE_ZONE_RADIUS .equ #20
MELEE_EXT_ZONE_RADIUS .equ #40
FIRE_STRIP_WIDTH .equ #16
FIRE_FLANK_WIDTH .equ #48
SCATTER_AREA_SIZE .equ #25

_actor_adj_x .equ generic_bytes+18
_actor_adj_y .equ generic_bytes+19
_target_x .equ generic_bytes+21
_target_y .equ generic_bytes+22

run_ai:
  LDA player_dead
  BEQ +
    LDA #0 ; if the player dies, the enemies stop doing
    STA actor_control
    JMP +exit_run_ai
  +:
  
  LDX actor_data_pointer
  
  ; make the actor's position for ai the center of its hitbox
  LDA actors+ACT_X,X
  SEC
  SBC #4
  STA _actor_adj_x
  LDA actors+ACT_Y,X
  STA _actor_adj_y
  
  CPX #(<dragon)-(<actors)
  BNE +
    JSR ai_attack_phase ; dragon only attacks
    JMP +exit_run_ai
  +:

  LDA ai_state_msb
  BNE +
    ; msb = 0, scatter
    
    JSR ai_scatter_phase
    
    JMP +exit_run_ai
  +:
    ; msb > 0, attack
    
    JSR ai_attack_phase
  
  +exit_run_ai:
  LDA actor_control
  AND #%11001111 ; AI can't press start or select
  STA actor_control
  RTS
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ai_scatter_phase:
  LDA actors+ACT_AI_STATE,X
  BNE +
    JSR ai_scatter
    JMP +exit
  +:
  SEC
  SBC #1
  BNE +
    JSR ai_flee
    JMP +exit
  +:
  SEC
  SBC #1
  BNE +
    JSR ai_flee_melee_approach
    JMP +exit
  +: 
  SEC
  SBC #1
  BNE +
    JSR ai_flee_melee_attack
    JMP +exit
  +:
  
  ; code shouldn't get here, but just in case:
  LDA #0
  STA actor_data_pointer+ACT_AI_STATE

  +exit:
  RTS
  
ai_attack_phase:
  LDA #0
  STA actor_control
  
  LDA actors+ACT_AI_STATE,X
  BNE +
    JSR ai_melee_approach
    JMP +exit
  +:
  SEC
  SBC #1
  BNE +
    JSR ai_melee_attack
    JMP +exit
  +:
  SEC
  SBC #1
  BNE +
    JSR ai_range_approach
    JMP +exit
  +: 
  SEC
  SBC #1
  BNE +
    JSR ai_range_attack
    JMP +exit
  +:
  
  ; code shouldn't get here, but just in case:
  LDA #0
  STA actor_data_pointer+ACT_AI_STATE

  +exit:
  
  RTS
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ai_melee_approach: ; a0
  ; action:
  ; move towards the nearest corner of the MELEE_ZONE
  ; level 3 and up, will walk 1 axis if in FIRE_DANGER
  
  ; call ai_get_direction to figure out which corner to go to
  call4 ai_get_direction, _actor_adj_x, _actor_adj_y, player+ACT_X, player+ACT_Y
  
  LDA returns+0
  AND DOWN_BUTTON
  BEQ +player_is_up
    
    LDA returns+0
    AND LEFT_BUTTON
    BEQ +player_is_right
      
      ; player is down left, target opposite
      LDA player+ACT_X
      CLC
      ADC MELEE_ZONE_RADIUS-8
      STA _target_x
      
      LDA player+ACT_Y
      SEC
      SBC MELEE_ZONE_RADIUS-2
      STA _target_y
      
      call4 ai_get_direction, _actor_adj_x, _actor_adj_y, _target_x, _target_y
      
      LDA returns+0
      STA actor_control
      
      JMP +state_shifts
    +player_is_right:
    
      ; player is down right, target opposite
      LDA player+ACT_X
      SEC
      SBC MELEE_ZONE_RADIUS-2
      STA _target_x
      
      LDA player+ACT_Y
      SEC
      SBC MELEE_ZONE_RADIUS-2
      STA _target_y
      
      call4 ai_get_direction, _actor_adj_x, _actor_adj_y, _target_x, _target_y
      
      LDA returns+0
      STA actor_control
    
      JMP +state_shifts
  +player_is_up:
    
    LDA returns+0
    AND LEFT_BUTTON
    BEQ +player_is_right
    
      ; player is up left, target opposite
      LDA player+ACT_X
      CLC
      ADC MELEE_ZONE_RADIUS-8
      STA _target_x
      
      LDA player+ACT_Y
      CLC
      ADC MELEE_ZONE_RADIUS-2
      STA _target_y
      
      call4 ai_get_direction, _actor_adj_x, _actor_adj_y, _target_x, _target_y
      
      LDA returns+0
      STA actor_control
    
      JMP +state_shifts
    +player_is_right:
    
      ; player is up right, target opposite
      LDA player+ACT_X
      CLC
      SBC MELEE_ZONE_RADIUS-2
      STA _target_x
      
      LDA player+ACT_Y
      CLC
      ADC MELEE_ZONE_RADIUS-2
      STA _target_y
      
      call4 ai_get_direction, _actor_adj_x, _actor_adj_y, _target_x, _target_y
      
      LDA returns+0
      STA actor_control
    
  
  
  ; state shifts:
  ; if in MELEE_ZONE and not waiting for attack cooldown, enter melee attack
  ; if first frame of phase, and has fire, 1/2 of entering range approach
  +state_shifts:
  JSR ai_is_in_melee_zone
  BEQ +
    LDA #1 ; melee attack
    STA actors+ACT_AI_STATE,x
    JMP +exit
  +:
  
  LDA ai_state_timer
  BNE +exit
  LDA actors+ACT_MANA,x
  BEQ +exit
  
  JSR rng
  LDX actor_data_pointer
  LDA rng_seed+0
  AND #%00000001
  BNE +exit
  
  LDA #2 ; range approach
  STA actors+ACT_AI_STATE,x
  
  
  +exit:
  RTS
  
ai_melee_attack: ; a1
  ; actions:
  ; move towards in-line axis of player
  ; face player
  ; if above conditions are met, swing
  
  ; state shifts:
  ; if swinging, enter melee approach
  ; if not within MELEE_ZONE, enter melee approach
  
  LDA #0
  STA actor_control
  RTS
  
ai_range_approach: ; a2
  ; actions:
  ; move towards nearest FIRE_FLANK
  ; if in danger of player fire, move perpendicular to fire
  
  ; state shifts:
  ; if in FIRE_FLANK, and player fireball not on field, and own fireball not on field, enter range attack

  LDA B_BUTTON
  STA actor_control
  RTS
  
ai_range_attack: ; a3
  ; actions:
  ; move towards fire zone
  ; face player
  ; if above conditions are met, fire
  
  ; state shifts:
  ; if out of fireballs, enter melee approach
  ; if own fireball is on field, enter range approach
  
  LDA #0
  STA actor_control
  RTS
  
ai_scatter: ; s0
  ; actions:
  ; move towards scatter area as assigned by class
  ; if in target scatter area, move in random direction, reroll every 16 ticks
  
  ; state shifts:
  ; if in danger, enter flee
  
  LDA #0
  STA actor_control
  RTS

ai_flee: ; s1
  ; actions:
  ; move towards a randomly selected corner
  
  ; state shifts:
  ; if in target scatter area and still in danger, pick a new corner
  ; if in melee zone, and state_timer < 32, enter flee melee attack
  LDA #0
  STA actor_control
  RTS
  
ai_flee_melee_approach: ; s2
  ; change state to flee
  
  JSR ai_flee
  RTS
  
ai_flee_melee_attack: ; s3
  JSR ai_melee_attack
  RTS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  

ai_is_in_melee_zone:
  LDA player+ACT_X
  SEC
  SBC MELEE_ZONE_RADIUS
  CMP _actor_adj_x
  BCS +not_in_zone
  
  LDA player+ACT_X
  CLC
  ADC MELEE_ZONE_RADIUS
  CMP _actor_adj_x
  BCC +not_in_zone
  
  LDA player+ACT_Y
  SEC
  SBC MELEE_ZONE_RADIUS
  CMP _actor_adj_y
  BCS +not_in_zone
  
  LDA player+ACT_Y
  CLC
  ADC MELEE_ZONE_RADIUS
  CMP _actor_adj_y
  BCC +not_in_zone
  
  LDA #1
  JMP +exit
  
  +not_in_zone:
  LDA #0
  +exit:
  RTS
  
ai_is_in_ext_melee_zone:
  RTS
  
ai_is_in_fire_zone:
  RTS
  
ai_is_in_diag_fire_zone:
  RTS
  
ai_is_in_fire_flank:
  RTS

ai_is_in_diag_fire_flank:
  RTS
  
ai_in_danger_of_fire:
  RTS
  
ai_in_danger:
  RTS
  
ai_is_in_scatter_area:
  RTS
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ai_get_direction:
  ; takes actor x,y on a0, a1; target x,y on a2, a3
  ; returns buttons to direction on r0
  
  LDA #0
  STA returns+0
  
  LDA arguments+0
  CMP arguments+2 ; cmp x co-ords
  BEQ +check_y ; if they're equal, press no l/r buttons
  BCC +go_right
  
    LDA LEFT_BUTTON
    ORA returns+0
    STA returns+0
    
    JMP +check_y
  
  +go_right:
  
    LDA RIGHT_BUTTON
    ORA returns+0
    STA returns+0
    
  +check_y:
  
  LDA arguments+1
  CMP arguments+3 ; cmp y co-ords
  BEQ +done ; if they're equal, press no u/d buttons
  BCC +go_down
  
    LDA UP_BUTTON
    ORA returns+0
    STA returns+0
    
    JMP +done
  
  +go_down:
  
    LDA DOWN_BUTTON
    ORA returns+0
    STA returns+0
  
  +done:
  RTS
