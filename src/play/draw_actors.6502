draw_actors:
  LDX player_room
  LDA dungeon_map, X
  AND #%11110000 ; we only care about the enemies
  CLC
  ROR
  ROR
  ROR
  ROR
  STA enemies_in_room
  LDA player_room
  CMP boss_room
  BNE +
    LDA enemies_in_room
    ORA #%00010000
    STA enemies_in_room
  +:
  
  LDA #0
  STA actor_data_pointer
  STA actor_sprite_pointer
  LDA #$10
  STA actor_sprite_rom_pointer
  
  JMP skip_enemy_in_room_check ; player is always in the room
  
  -:
    ; skip to the next one if the enemy isn't in the room
    LDA enemies_in_room
    AND #%00000001
    CMP #0
    BEQ +
    skip_enemy_in_room_check:
      JSR draw_spec_actor
    +:
      ;move pointers to next
      LDA #ACT_SPRITE_DATA_LENGTH
      CLC
      ADC actor_sprite_pointer
      STA actor_sprite_pointer
      
      LDA #ACTOR_DATA_LENGTH
      CLC
      ADC actor_data_pointer
      STA actor_data_pointer
      
      LDA #$10
      CLC
      ADC actor_sprite_rom_pointer
      STA actor_sprite_rom_pointer
      CLC
      ROR enemies_in_room
  LDA enemies_in_room
  CMP #0
  BNE -
  
  RTS
  
draw_spec_actor:
  JSR draw_body
  JSR draw_fireball
  JSR check_if_draw_readout
  
  ;TEST CODE
  LDA #1
  LDX actor_data_pointer
  CLC
  ADC actors+ACT_Y,X
  STA actors+ACT_Y,X
  STA actors+ACT_FIRE_Y,X
  STA actors+ACT_FIRE_X,X
  
  ; TEST CODE
  LDX actor_data_pointer
  LDA #1
  CLC
  ADC actors+ACT_ANIM_TIMER,X
  STA actors+ACT_ANIM_TIMER,X
  STA actors+ACT_FIRE_ANIM_TIMER,X
  
  JSR rng
  LDX actor_data_pointer
  LDA rng_seed
  AND #%00001111
  BNE +
    INC actors+ACT_READOUT_VALUE,X
  +:
  JSR rng
  LDX actor_data_pointer
  LDA rng_seed
  AND #%00001111
  BEQ +
    LDA #1
    JMP ++
  +:
    LDA #0
  ++:
    STA actors+ACT_READOUT_TIMER,X
  
  RTS
  
draw_body:
  ; put body in body spot
  
  LDX actor_data_pointer
  LDA actors+ACT_X,X
  SEC
  SBC #4 ;actor data holds location of middle of leg sprite
  LDX actor_sprite_pointer
  STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_X,X
  STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_X,X
  
  LDX actor_data_pointer
  LDA actors+ACT_Y,X
  SEC
  SBC #4 ;actor data holds location of middle of leg sprite
  LDX actor_sprite_pointer
  STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_Y,X
  SEC
  SBC #8
  STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_Y,X
  
  ; make body be right body
  LDX actor_data_pointer
  LDA actors+ACT_FACE,X
  BNE +
  ; GOING DOWN
    LDA actor_sprite_rom_pointer
    ;"add 0"
    LDX actor_sprite_pointer
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_I,X
    
    CLC
    ADC #ACT_NUM_FRAMES
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_I,X
    
    ; get step side
    
    LDX actor_data_pointer
    LDA actors+ACT_ANIM_TIMER,X
    
    AND #%00010000
    CLC
    ROL
    ROL
    
    STA generic_bytes
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    AND #%00111111
    ORA generic_bytes
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    AND #%00111111
    ORA generic_bytes
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    
    JMP ++
  +:
  SEC
  SBC #1
  BNE +
  ; GOING UP
    LDA actor_sprite_rom_pointer
    CLC
    ADC #1
    LDX actor_sprite_pointer
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_I,X
    
    CLC
    ADC #ACT_NUM_FRAMES
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_I,X
    
    ; get step side
    
    LDX actor_data_pointer
    LDA actors+ACT_ANIM_TIMER,X
    
    AND #%00010000
    CLC
    ROL
    ROL
    
    STA generic_bytes
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    AND #%00111111
    ORA generic_bytes
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    AND #%00111111
    ORA generic_bytes
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    JMP ++
  +:
  SEC
  SBC #1
  BNE +
  ; GOING RIGHT
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    AND #%00111111
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    AND #%00111111
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    
    JMP shared_lr_stepside_rendering
  +:
  SEC
  SBC #1
  BNE ++
  ; GOING LEFT
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    AND #%00111111
    ORA #%01000000
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_A,X
    
    LDX actor_sprite_pointer
    LDA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    AND #%00111111
    ORA #%01000000
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_A,X
    
    shared_lr_stepside_rendering:
    LDX actor_data_pointer
    LDA actors+ACT_ANIM_TIMER,X
    AND #%00010000
    CLC
    ROL
    ROL
    ROL
    ROL
    ADC #2
    STA generic_bytes
    
    LDA actor_sprite_rom_pointer
    CLC
    ADC generic_bytes
    LDX actor_sprite_pointer
    STA $0200+ACT_SPRITE_HEAD+SPRITE_DATA_I,X
    
    CLC
    ADC #ACT_NUM_FRAMES
    STA $0200+ACT_SPRITE_BODY+SPRITE_DATA_I,X
    
  ++:
  RTS
  
draw_fireball:
  ;set fireball x
  LDX actor_data_pointer
  LDA actors+ACT_FIRE_X, X
  LDX actor_sprite_pointer
  STA $0200+ACT_SPRITE_FIRE+SPRITE_DATA_X, X
  
  ;set fireball y
  LDX actor_data_pointer
  LDA actors+ACT_FIRE_Y, X
  LDX actor_sprite_pointer
  STA $0200+ACT_SPRITE_FIRE+SPRITE_DATA_Y, X
  
  ;set fireball sprite
  LDA #$1E ;fireball sideways sprite
  STA generic_bytes
  
  LDX actor_data_pointer
  LDA actors+ACT_FIRE_FACE
  AND #%00000010 ; %1x faces are sideways, 0x faces are up-down
  BNE +
    INC generic_bytes 
  +:
  LDX actor_sprite_pointer
  LDA generic_bytes
  STA $0200+ACT_SPRITE_FIRE+SPRITE_DATA_I, X
  
  ; set reflections
  LDX actor_data_pointer
  LDA actors+ACT_FIRE_FACE,X
  AND #%00000001 ; the last bit determines if the fire faces up|left
  CLC
  ROL ; move the bit to the Flip Horizontal position
  ROL
  ROL
  ROL
  ROL
  ROL 
  STA generic_bytes+1
  
  LDX actor_data_pointer
  LDA actors+ACT_FIRE_ANIM_TIMER,X
  AND #%00010000
  CLC
  ROL ; move the bit to the Flip Vertical position
  ROL
  ROL
  STA generic_bytes+2
  
  LDA generic_bytes
  CMP #$1E ; is fireball side-to-side?
  BEQ +
    ;swap which things controls which axis of reflection
    LDA generic_bytes+1
    CLC
    ROL
    STA generic_bytes+1
    
    LDA generic_bytes+2
    CLC
    ROR
    STA generic_bytes+2
  +:
  
  ;reflection mask
  LDA generic_bytes+1
  ORA generic_bytes+2
  STA generic_bytes+3
  
  LDX actor_sprite_pointer
  LDA $0200+ACT_SPRITE_FIRE+SPRITE_DATA_A,X
  AND #%00111111
  ORA generic_bytes+3
  STA $0200+ACT_SPRITE_FIRE+SPRITE_DATA_A,X
  
  RTS
  
check_if_draw_readout:
  LDX actor_data_pointer
  LDA actors+ACT_READOUT_VALUE
  BEQ +
    ; yes digit display
    
    JMP ++
  +:
    ; no digit display
    LDX actor_sprite_pointer
    LDA #$FF
    STA $0200+ACT_SPRITE_DIG1+SPRITE_DATA_Y,X
    STA $0200+ACT_SPRITE_DIG2+SPRITE_DATA_Y,X
    STA $0200+ACT_SPRITE_DIG3+SPRITE_DATA_Y,X
  ++:
  
  RTS
