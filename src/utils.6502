rng: ;loads A and X
  LDX #8
  LDA rng_seed+0
--:
  ASL
  ROL rng_seed+1
  BCC +
  EOR #$2D
+:
  DEX
  BNE --
  STA rng_seed+0
  CMP #0
  RTS

pull_nt_buffer:
  LDX #$00 ;buffer pointer
  LDY #$00 ;entry length counter
  -:
    CPX nt_update_buf_wi
    BEQ finish_nt_update:
    CPY #$00
    BNE +
      ;we are at the start of a new entry
      LDY nt_buffer, X
      INX
      
      LDA $2002 ; read PPU status to reset the high/low latch
      
      LDA nt_buffer, X
      STA $2006 ; write the high byte of address
      INX
      DEY
      
      LDA nt_buffer, X
      STA $2006 ; write the low byte of address
      INX
      DEY
    +:
      LDA nt_buffer, X
      STA $2007 ; write to ppu
      INX
      DEY
      JMP -
      
  finish_nt_update:
  
  LDA #0
  STA nt_buffer_overflow
  STA nt_update_buf_wi
  STA nt_update_buf_wc
  
  RTS
  
_begin_nt_buffer_write:
  ;if the previous entry is unfinished, finish it
  LDA nt_update_buf_wi
  CMP nt_update_buf_wc
  BEQ +
    JSR _end_nt_buffer_write
  +:
  
  LDA nt_update_buf_wi
  CMP #$fb ;minimum space needed for a new entry
  BCC +
    LDA #1
    STA nt_buffer_overflow
  +:
  
  LDA nt_buffer_overflow
  BNE +
  
  LDX nt_update_buf_wi
  LDA #$00
  STA nt_buffer, X ;value will be updated to reflect length of update
                   ;change will occur when end_nt_buffer_write is called
  
  INX
  LDA nt_buf_in_hi
  STA nt_buffer, X
  
  INX
  LDA nt_buf_in_lo
  STA nt_buffer, X
  
  INX
  STX nt_update_buf_wc
  
  +:
  
  RTS
  
_write_to_nt_buffer:
  LDA nt_buffer_overflow
  BNE +
  
  LDA nt_buf_in_dt
  LDX nt_update_buf_wc
  STA nt_buffer, X
  INC nt_update_buf_wc
  
  ;buffer overflow check
  LDA nt_update_buf_wc
  CMP #$FE
  BNE +
    LDA #1
    STA nt_buffer_overflow
    JSR _end_nt_buffer_write
  +:
  RTS
  
_end_nt_buffer_write:
  ;find and write data lentgh
  LDA nt_update_buf_wc
  SBC nt_update_buf_wi
  LDX nt_update_buf_wi
  STA nt_buffer, X
  ;update `write initial` using `write current`
  LDX nt_update_buf_wc
  STX nt_update_buf_wi
  RTS
  
byte_to_dec:
  LDA arguments
  
  ;100's place
  LDX #0
  -:
    CMP #100
    BCC +
      INX
      ;SEC
      SBC #100
    JMP -
  +:
  STX returns+0
  
  ;10's place
  LDX #0
  -:
    CMP #10
    BCC +
      INX
      ;SEC
      SBC #10
    JMP -
  +:
  STX returns+1
  
  ;1's place
  STA returns+2
  
  RTS
  
get_tile_under_point:
  LDA arguments+0 ; x-pos
  LSR
  LSR
  LSR ; LSR 3 times to divide by 8
  STA arguments+0
  
  LDA #0
  STA arguments+2 ; will be used to shift bits into
  STA arguments+3
   
  LDA arguments+1 ; y-pos
  AND #%11111000  ; only care about y-pos/8
                  ; we don't need to bit-shift as we're about to multiply by 4.
                  ; If we DID bit-shift, it would be * 32 instead
  CLC
  ; ASL twice to multiply by 4
  ; bits shifted off are carried into arguments+2
  ASL
  ROL arguments+2
  ASL
  ROL arguments+2
  STA arguments+1
  
  ; NT memory location = $2000 + x/8 + y*4
  LDA arguments+0
  CLC
  ADC arguments+1
  STA arguments+3
  
  LDA arguments+2
  ADC #$20 ; +1 if carry
  STA arguments+2
  
  ; we now have the memory address of the tile in args 2 and 3
  
  LDA $2002 ; read PPU status to reset the high/low latch
  
  LDA arguments+2
  STA $2006 ; write high byte
  LDA arguments+3
  STA $2006 ; write low byte
  
  ; read the tile id
  LDA $2007
  STA returns+0
  
  LDA #$00 ; setting the address (above) also sets scroll position
           ; why? I think they just hate us.
  STA $2005
  STA $2005
  
  ;JSR reset_scroll ;???????????????
  
  RTS
